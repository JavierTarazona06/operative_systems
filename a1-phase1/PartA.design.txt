# Namme: Javier Andres Tarazona Jimenez
# NSID: elr490
# Student Number: 11411898

Part A Design

Design will be explained for each section.

# Part A.1

In essence the idea is to write a Windows program that creates 
multiple threads to compute squares of positive integers in 
parallel until a deadline without synchronization between threads.

So we have:
- Parent Thread:
	- Created child threads
	- Off until deadline
	- If deadline before threads getting completed, 
	global variable to exit.
- Child threads:
	- Compute square of positive integers
	- Remains checking global variable of parent 
	to know when to stop.
	- Call Square function. Performs operations without
	multiplying for filling the stack.
	- Each call to square must be counted (the invocation).
	
- Parameters:
	- threads: which are child threads
	- deadline: time in milliseconds to run threads
	- size: Max numerical limit that squares will reach
	
Landing the idea, we have:

- Global variables:
	- Must be volatile as it will be changing all the time 
	and different parts of the code will be using it.
	volatile bool keepRunning = true;
	- Invocation Count of Square function
	- threads array where thread handles will be stored
	- threads_id array where thread id handles will be stored
	- time_start array that stores beginning time for each thread
	
- Thread Functions (Child):
	- Square of integers
	- Check keepRunning. If false -> stop
	- Calls computeSquare function
	
- Compute square function:
	- Calls square operation and GetTickCount()
	- Prints elapsed time and invocation count towards being completed
	
- Square Function:
	- Performs algorithm:
		if (N==0) return 0;
		return Square(N-1) + N + N -1;
	- Calls GetCurrentThreadId() for the invocation_count sum
	- Counts +1 in invocation_count
	
- Parent Thread (Main Function):
	- Creates child threads (CreateThread())
	- If deadline is reached -> set keepRunning false
	- (Not Sure Yet) Initializes critical section for invocation_count 		
	thread-safe_access
	- Created thread, pass complete_squares()
	- Waits for the deadline using Sleep()
	- Terminates threads and waits for its completion using 
	TerminateThread() and WaitForSingleObject()
	- (Not sure yet) Cleans up resources with 
	DeleteCriticalSection()
	
- Libraries:
	- <windows.h> for windows functions
	- <atomic> a thread global safe state
	- <stdio.h> input and output operations
	- <stdlib.h> for memory, process and conversions control
	
	
# Part A.2

In this section, Pthreads of POSIX Threads will be used. Actually, the 
key differences between Win32 and Linux versions is the syntax for thread 
creation and the communication processes. Here we can also print the 
statistics for threads that have not finished when deadline is reached.

Example of differences between windows and linux:
- Creation: pthread_create()
- Termination: pthrread_cancel()
- Measure time: gettimeofday()
- Here we are not creating a shared flag for the whole program. The parent 
will terminate thread that didn't do so by deadline.

Landing:

- Libraries:
	- <unistd.h> Access to various system calls and POSIX 	
	(Portable Operating System Interface)
	- <sys/time.h> Provides structures and functions for 
	manipulating time and timers.
	- <signal.h> Provides functions for handling signals in UNIX-
	based systems.
	
Main changes compared to the Windows version:
- Threads will be terminated using pthread_cancel(). The time 
management will be with the parent process setting an alarm with 
alarm() at the time of the deadline. 

- Signal handler (killThreads()) is invoked, cancelling all threads 
that over-passed deadline.

- Now each thread has an invocation counter, earliest invocation_count.

- Mutexes will be used as synchronization mechanisms for this 
multi-thread program. This is for preventing the famous race conditions 
where a lot of threads are competing the access of shared resources 
(like the counter) at the same time.
	- pthread_mutex_lock() will be used for locking the mutex. Is 
	is already blocked, a queue will be created.
	- pthread_mutex_unlock() will unlocking. This allow other 	
	threads to use the resource.
	
- Finally, SIGALRM will be used to activate the deadline.  When the 
signal occurs, the function killthreads() will cancel all the threads. 
It prints those who were terminated.


# Part A.3

The last section asks to implement the program with POSIX (stands for 
Portable Operating System Interface) Thread, that means that I could 
exit the threads in any way. So, as I am not expected to use 
pthread_join() for waiting threads termination, then I would exit 
the threads during the running, when required.

In other words, instead of joining them, there would 2 options. 
1. Threads terminate by themselves
2. Responsibility of the parent thread

Function killThreads(int) would be used to terminate threads by 
the signal handler.

At the end, new changes are going to be the followinf:
- Thread Exit: Now will be used with pthread_exit() when work is 
completed. Thus, it won't be needed to join threads in the 
parent thread.
-Like the previous part, the parent thread set an alarm() on 
deadline. Then SIGALRM invokes killThreads(). This methods would 
terminate active threads using pthread_cancel(). Note that we will 
use this function when deadline is exceeded too.
