/* NAME: Javier Andres Tarazona Jimenez, Nahian Sajid 
   NSID: elr490, Zas742
   Student Number: 11411898, 11309563

   CMPT 332 Term 1 2024

   Assignment 1*/

# Part C: List Library

The goal here is to implement a list library that manages a collection of nodes, each storing a single item. All memory allocation for lists and nodes happens at the start, using static arrays. Dynamic memory allocation such as `malloc` will be avoided, and everything will be pulled from pre-allocated memory pools.

### So we have:
- **Lists**:
    - Each list will store a sequence of nodes and keep track of the head (first node), tail (last node), and the current node that’s being manipulated.
    - These lists will be stored in a fixed array called `list_pool[]` with a maximum number of lists (`MAX_LISTS`).

- **Nodes**:
    - Each node will store one item and have links to both the next and previous nodes (i.e., a doubly linked list).
    - Nodes will be allocated from a static array `node_pool[]`, with a maximum number of nodes (`MAX_NODES`).

### Landing the idea, we have:

- **Global variables**:
    - We’ll have arrays like `list_pool[]` and `node_pool[]` to store the lists and nodes, respectively.
    - Two indices, `free_list_index` and `free_node_index`, will keep track of the next available list and node in their respective pools.

### First, we need to create lists:
- **ListCreate()**:
    - This function will allocate a new list from `list_pool[]` and return a pointer to it. If all lists are in use, it returns `NULL`.
    - The head, tail, and current node pointers are initialized to `NULL`, and the count of items is set to 0.
    - We’ll ensure the function works correctly by checking list creation and verifying no errors are encountered.

### Then, we handle list operations:
- We’ll implement functions like `ListCount()`, `ListFirst()`, and `ListLast()` to navigate the list and count items.
    - **ListCount()** will return the number of items in a list.
    - **ListFirst()** will set the current pointer to the first node and return the item stored in it.
    - **ListLast()** will move the current pointer to the last node and return the corresponding item.
    - We’ll verify these functions with both empty and non-empty lists to ensure proper functionality.

### Adding and removing items:
- We need functions like `ListAdd()`, `ListInsert()`, and `ListRemove()` to manage items.
    - **ListAdd()** adds a new item after the current node and makes the new item the current node.
    - **ListInsert()** inserts an item before the current node.
    - **ListRemove()** removes the current node from the list and returns the item.
    - We’ll test adding and removing nodes in various scenarios (e.g., empty lists, lists with multiple nodes) to ensure proper functionality and pointer updates.

### Managing lists:
- We also need functions to manage lists themselves, such as **ListConcat()** and **ListFree()**.
    - **ListConcat()** will append all the nodes from one list (List2) to another (List1), and then List2 will no longer exist.
    - **ListFree()** will free the entire list and its nodes.
    - Additional functions like **ListTrim()** (removing the last item) and **ListSearch()** (finding items using a comparison function) will also be implemented.

### Memory management:
- All memory for lists and nodes comes from the pre-allocated arrays `list_pool[]` and `node_pool[]`. Once memory is exhausted, no more lists or nodes can be created.
- To comply with the assignment, no dynamic memory allocation (`malloc` or `free`) will occur after program initialization.

### Next steps:
- We’ll start by implementing basic functions for list creation and adding items.
- Once the basics are complete, we’ll move on to advanced operations like concatenating lists and searching for items.
- Testing will follow every implementation stage to ensure functionality and proper memory management.

The overall goal is to gradually implement the entire list library, testing and validating each function as we go, to meet the assignment requirements fully.

